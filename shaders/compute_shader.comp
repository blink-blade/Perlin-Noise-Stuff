#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;
uniform vec2 pos;

struct corner {
    float x;
    float y;
    vec2 gradientVec;
};

float interpolate(float a0, float a1, float w) {
    return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;
}

float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
}

vec2 randomGradient(float ix, float iy) {
    vec2 v;
    v.x = sin(ix * rand(vec2(ix, iy)));
    v.y = cos(iy * rand(vec2(ix, iy)));
    return v;
}

// Sample Perlin noise at coordinates x, y
float noise(float x, float y) {
    // Get the corner positions, x0 is left, x1 is left
    float x0 = int(x); 
    float y0 = int(y);
    float x1 = x0 + 1;
    float y1 = y0 + 1;

    // Compute Interpolation weights
    float sx = x - x0;
    float sy = y - y0;

    corner tlCorner;
    corner blCorner;
    corner trCorner;
    corner brCorner;
    tlCorner.x = x0, tlCorner.y = y0;
    blCorner.x = x0, blCorner.y = y1;
    trCorner.x = x1, trCorner.y = y0;
    brCorner.x = x1, brCorner.y = y1;
    tlCorner.gradientVec = randomGradient(tlCorner.x, tlCorner.y);
    blCorner.gradientVec = randomGradient(blCorner.x, blCorner.y);
    trCorner.gradientVec = randomGradient(trCorner.x, trCorner.y);
    brCorner.gradientVec = randomGradient(brCorner.x, brCorner.y);

    // Get distance vectors(A vector from the corner which points to the tile) for each corner of the octant.
    vec2 tlDistanceVector;
    vec2 blDistanceVector;
    vec2 trDistanceVector;
    vec2 brDistanceVector;
    tlDistanceVector.x = x - tlCorner.x, tlDistanceVector.y = y - tlCorner.y; 
    blDistanceVector.x = x - blCorner.x, blDistanceVector.y = y - blCorner.y; 
    trDistanceVector.x = x - trCorner.x, trDistanceVector.y = y - trCorner.y; 
    brDistanceVector.x = x - brCorner.x, brDistanceVector.y = y - brCorner.y; 

    // Get dot product from the distance vectors and the gradient vectors.
    float tlDotProduct = (tlDistanceVector.x * tlCorner.gradientVec.x) + (tlDistanceVector.y * tlCorner.gradientVec.y);
    float blDotProduct = (blDistanceVector.x * blCorner.gradientVec.x) + (blDistanceVector.y * blCorner.gradientVec.y);
    float trDotProduct = (trDistanceVector.x * trCorner.gradientVec.x) + (trDistanceVector.y * trCorner.gradientVec.y);
    float brDotProduct = (brDistanceVector.x * brCorner.gradientVec.x) + (brDistanceVector.y * brCorner.gradientVec.y);

    // Interpolation.
    float tlTrInterpolation = interpolate(tlDotProduct, trDotProduct, sx);
    float blBrInterpolation = interpolate(blDotProduct, brDotProduct, sx);

    return interpolate(tlTrInterpolation, blBrInterpolation, sy);
}

float layeredNoise(float x, float y, int layerAmount, float frequency) {
    // noiseMap[y][x] = -x + y + 10;
    float amp = 1;
    float val = 0;
    float freq = frequency / 50.0;
    for (int i = 0; i < layerAmount; i++) {
        val += noise(x * freq, y * freq) * amp;
        freq *= 2;
        amp /= 2;
    }
   return val;
}

void main() {
    ivec2 texPos = ivec2(gl_GlobalInvocationID.xy);
    imageStore(screen, texPos, vec4(layeredNoise(pos.x + texPos.x, pos.y + texPos.y, 4, 1) * 25, 0.0, 0.0, 0.0));
}
